(self.webpackChunkdqlx_docs=self.webpackChunkdqlx_docs||[]).push([[725],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return d},kt:function(){return m}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(t),m=r,h=c["".concat(s,".").concat(m)]||c[m]||u[m]||i;return t?a.createElement(h,o(o({ref:n},d),{},{components:t})):a.createElement(h,o({ref:n},d))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=c;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},4786:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return o},metadata:function(){return l},toc:function(){return s},default:function(){return d}});var a=t(2122),r=t(9756),i=(t(7294),t(3905)),o={sidebar_position:1},l={unversionedId:"mutations/set",id:"mutations/set",isDocsHomePage:!1,title:"Set",description:"In this section we'll learn how to Insert and Update data in Dgraph",source:"@site/docs/mutations/set.md",sourceDirName:"mutations",slug:"/mutations/set",permalink:"/dqlx/docs/mutations/set",editUrl:"https://github.com/fenos/dqlx-docs/edit/master/docs/mutations/set.md",version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Multiple Query Blocks",permalink:"/dqlx/docs/queries/multiple-query-blocks"},next:{title:"Delete",permalink:"/dqlx/docs/mutations/delete"}},s=[{value:"Inserts",id:"inserts",children:[]},{value:"Upserts",id:"upserts",children:[{value:"Logical Upsert",id:"logical-upsert",children:[]},{value:"Conditional Upsert",id:"conditional-upsert",children:[]}]}],p={toc:s};function d(e){var n=e.components,t=(0,r.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In this section we'll learn how to ",(0,i.kt)("strong",{parentName:"p"},"Insert")," and ",(0,i.kt)("strong",{parentName:"p"},"Update")," data in Dgraph"),(0,i.kt)("p",null,"Operations that mutate the storage are called ",(0,i.kt)("inlineCode",{parentName:"p"},"Mutations")," we are going to use a ",(0,i.kt)("inlineCode",{parentName:"p"},"Set")," mutation\nto store and update data."),(0,i.kt)("p",null,"If we provide a valid ",(0,i.kt)("inlineCode",{parentName:"p"},"uid")," within the node we are trying to operate on, the operation becomes an ",(0,i.kt)("inlineCode",{parentName:"p"},"Update"),".\nIf the ",(0,i.kt)("inlineCode",{parentName:"p"},"uid")," we provided doesn't exist it will try to insert it. "),(0,i.kt)("p",null,"The set operation works like an ",(0,i.kt)("inlineCode",{parentName:"p"},"Upsert")," operation over the ",(0,i.kt)("inlineCode",{parentName:"p"},"uid")),(0,i.kt)("h2",{id:"inserts"},"Inserts"),(0,i.kt)("p",null,"If we want to store data, we'll make sure that we don't provide any ",(0,i.kt)("inlineCode",{parentName:"p"},"uid")," to our nodes.\nDgraph will generate one automatically for us."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'data := []map[string]interface{}{\n    {\n        "name": "Leo",\n        "animal": "Cat",\n        "age": 6,\n    },\n    {\n        "name": "Ollie",\n        "animal": "Cat",\n        "age": 2,\n    },\n    {\n        "name": "Charlie",\n        "animal": "Dog",\n        "age": 3,\n    },\n}\n\nresponse, err := db.Mutation().Set(data).Execute(ctx)\n')),(0,i.kt)("p",null,"You can access the newly generated ",(0,i.kt)("inlineCode",{parentName:"p"},"uids")," of the above records form the ",(0,i.kt)("inlineCode",{parentName:"p"},"response")," object"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"response.Raw.Uids // map[string]string\n")),(0,i.kt)("p",null,"If you try to print the ",(0,i.kt)("inlineCode",{parentName:"p"},"Uids")," you'll quickly notice that there is no easy way to understand\nwhich record belongs to which ",(0,i.kt)("inlineCode",{parentName:"p"},"id"),". "),(0,i.kt)("p",null,"The reason is that ",(0,i.kt)("inlineCode",{parentName:"p"},"maps")," in go are not ordered, so we cannot rely\non the order of the ids to determine which id belongs to which record."),(0,i.kt)("p",null,'To overcome this limitation, we use the "blank" node concept.\nWe can assign a unique name to our nodes ',(0,i.kt)("inlineCode",{parentName:"p"},"ids")," so that we can refer to them\nlater. "),(0,i.kt)("p",null,"The syntax for defining a name to our node is: ",(0,i.kt)("inlineCode",{parentName:"p"},"_:{name}")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'data := []map[string]interface{}{\n    {\n        "uid": "_:leo",\n        "name": "Leo",\n        "animal": "Cat",\n        "age": 6,\n    },\n    {\n        "uid": "_:ollie",\n        "name": "Ollie",\n        "animal": "Cat",\n        "age": 2,\n    },\n    {\n        "uid": "_:charlie",\n        "name": "Charlie",\n        "animal": "Dog",\n        "age": 3,\n    },\n}\n\nresp, err := db.Mutation().Set(data).Execute(ctx)\n\n// Now we can access the id knowing exactly which id belongs to which node\nresp.Raw.Uids["leo"]\nresp.Raw.Uids["ollie"]\nresp.Raw.Uids["charlie"]\n')),(0,i.kt)("h2",{id:"upserts"},"Upserts"),(0,i.kt)("p",null,"As previously mentioned, updates are behaving more like upserts.\nWe provide the ",(0,i.kt)("inlineCode",{parentName:"p"},"uid")," to the node we want to update and if it exists it will update it, else it will create one."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'data := []map[string]interface{}{\n    {\n        "uid": "0x1", // Provide ID\n        "age": 7,     // field to update\n    },\n}\n\nresp, err := db.Mutation().Set(data).Execute(ctx)\n')),(0,i.kt)("h3",{id:"logical-upsert"},"Logical Upsert"),(0,i.kt)("p",null,"If we want to upsert on other fields other than the ",(0,i.kt)("inlineCode",{parentName:"p"},"uid")," we use a combination of a ",(0,i.kt)("inlineCode",{parentName:"p"},"Query")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Mutation")),(0,i.kt)("p",null,"let\u2019s say we want to create a new user with ",(0,i.kt)("inlineCode",{parentName:"p"},"email")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," information.\nWe also want to make sure that one ",(0,i.kt)("inlineCode",{parentName:"p"},"email")," has exactly one corresponding ",(0,i.kt)("inlineCode",{parentName:"p"},"user")," in the database.\nTo achieve this, we need to first query whether a user exists in the database with the given email. If a user exists, we use its ",(0,i.kt)("inlineCode",{parentName:"p"},"UID")," to update the name information.\nIf the user doesn\u2019t exist, we create a new ",(0,i.kt)("inlineCode",{parentName:"p"},"user")," and update the ",(0,i.kt)("inlineCode",{parentName:"p"},"email")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," information."),(0,i.kt)("p",null,"We can achieve this with a single operation as following"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'data := []map[string]interface{}{\n    {\n        "uid": "uid(v)",\n        "email": "user@company1.io",\n        "name": "first name"\n    },\n}\n\nuserByEmailQuery := dqlx.Query(dqlx.EqFn("email", "user@company1.io")).\n    .Fields(`\n        v as uid\n        name\n    `)\n\nresp, err := db.Mutation().\n    Query(userByEmailQuery).\n    Set(data).\n    Execute(ctx)\n')),(0,i.kt)("h3",{id:"conditional-upsert"},"Conditional Upsert"),(0,i.kt)("p",null,"Conditional upsert allows to avoid the entire operation if a certain condition is met."),(0,i.kt)("p",null,"Imagine you want to only update a user by email if the email exists. If it doesn't you want to skip the operation\nand not insert the new record"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'data := []map[string]interface{}{\n    {\n        "uid": "uid(v)",\n        "email": "user@company1.io",\n        "name": "first name"\n    },\n}\n\nuserByEmailQuery := dqlx.Query(dqlx.EqFn("email", "user@company1.io")).\n    .Fields(`\n        v as uid\n        name\n    `)\n\ncondition := dqlx.Condition(dqlx.Eq("len(v)", "1"))\n\nresp, err := db.Mutation().\n    Query(userByEmailQuery).\n    Condition(condition).\n    Set(data).\n    Execute(ctx)\n')))}d.isMDXComponent=!0}}]);